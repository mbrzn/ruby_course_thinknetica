## Лекция
>[Teachbase](https://go.teachbase.ru/viewer/sessions/646509/materials/2078834)
![[2024-03-29 14_44_12-Teachbase – Brave.png]]
*load*
![[Untitled 51-1.png]]
Есть ли у классов id ?

- переменная объекта значит *nil* , пока не наполнится содержанием:
>![[git/ruby_course_thinknetica/kb/files/Ruby ООП.png]]
>только *go* наполняет *@speed*

>*атрибут* \=\= *instance variable*

>*конструктор* \=\= *инстанцирование объекта* 
>![[git/ruby_course_thinknetica/kb/files/Ruby ООП-1.png]]

- [x] вызов метода класса вызывается в конструкторе класса (в *initialize*) кажется нелогичным (как мининимум)
	- Здесь противоречие со смыслом слова *initialize*...
	- [x] правильное, совершенное программирование конечно должно исходить из *идеальности класса* - класс должен быть самодостаточен, а значит
		- вызывать собственные же методы, 
		- не зависеть от *внешних себе сигналов*
	- однако, наш случай иной, ведь *car* - это вещь прилагаемая к чему-то, к кому-то
		- значит метод *beep* в конструкторе совершенно невозможен
- [x] мышление о *класса* т.о. совершенно невозможно без мышления о некоем всеобщем *суперклассе*, который и будет **полагать** смыслы *методов ВСЕХ классов*, которые сами по себе *безумны*

![[git/ruby_course_thinknetica/kb/files/Ruby ООП-3.png]]

>Объект демонстрирует свои аргументы конструирования ![[git/ruby_course_thinknetica/kb/files/Ruby ООП-4.png]]

>*setter* метод в форме *\=*
>
![[git/ruby_course_thinknetica/kb/files/Ruby ООП-5.png]]
*\=* суть имя *set метода*

- [x] Нотация именования свойств `attr_write :speed` очень хороша: 
	- свойство предстает здесь *символом*, объектной однозначностью, *метод и свойство т.о. выступают ровно одной и той же вещью*.
>Макрокоманда создает переменную и *=* set-метод
>![[git/ruby_course_thinknetica/kb/files/Ruby ООП-6.png]]

>*@-переменные* использовать только для методов
>- *init...* и 
>- *get-* и *set-методов*
>- в *init...* нельзя использовать методы *get-* и *set-*
>	- можно лишь непосредственным присваиванием значения *@speed = speed*
>- а вот в остальных методах, наоборот принято использовать *get-* и *set-* методы.
>![[git/ruby_course_thinknetica/kb/files/Ruby ООП-7.png]]

> - [ ] здесь *speed* **НЕ** означает вызов *set-метода*, хотя и есть указание на *=-метод*. Здесь меняется *пограничная*(?) переменная *speed* (она и объектная и сигнальная).
>- а вот *self-указатель* пограничность устраняет, теперь *speed* значит именно *set-метод*:
>- ![[git/ruby_course_thinknetica/kb/files/Ruby ООП-8.png]]

>[[git/ruby_course_thinknetica/kb/ООП Взаимодействие классов и объектов - ror_beginner - Thinknetica Connect]]

## Что делать
- [ ] Воспроизвести упражнение статьи [[git/ruby_course_thinknetica/kb/ООП Взаимодействие классов и объектов - ror_beginner - Thinknetica Connect]]
- [ ] Составить диаграммы UML для классов и объектов статьи
- [ ] Перевести статью в статус документа, т.е. в форму [[Курс Asciidoc]]
- [ ] Опубликовать документ в отчете
- [ ] 